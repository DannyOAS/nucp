# patient/decorators.py - ENHANCED SECURITY VERSION
from functools import wraps
from django.shortcuts import redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.http import Http404
from patient.models import Patient
import logging

logger = logging.getLogger(__name__)

def patient_required_secure(view_func):
    """
    ENHANCED SECURITY: Decorator with comprehensive patient verification
    """
    @wraps(view_func)
    @login_required
    def wrapped_view(request, *args, **kwargs):
        # 1. Verify user is in patients group
        if not request.user.groups.filter(name='patients').exists():
            logger.warning(f"SECURITY: User {request.user.username} attempted patient access without patients group")
            messages.error(request, "Access denied.")
            return redirect('unauthorized')
        
        # 2. Verify patient profile exists and matches user
        try:
            patient = Patient.objects.select_related('user').get(user=request.user)
            
            # 3. CRITICAL: Verify user ID matches patient user ID
            if patient.user.id != request.user.id:
                logger.error(f"SECURITY BREACH: Patient user mismatch - Patient.user.id={patient.user.id}, request.user.id={request.user.id}")
                raise Http404("Patient not found")
            
            # 4. Add verified patient to request
            request.patient = patient
            request.patient_verified = True  # Security flag
            
            return view_func(request, *args, **kwargs)
            
        except Patient.DoesNotExist:
            logger.error(f"SECURITY: User {request.user.username} in patients group but no patient profile")
            messages.error(request, "Patient profile not found.")
            return redirect('unauthorized')
        except Exception as e:
            logger.error(f"SECURITY: Patient verification failed for user {request.user.username}: {str(e)}")
            raise Http404("Access denied")
    
    return wrapped_view

# patient/utils.py - ENHANCED SECURITY VERSION
def get_current_patient_secure(request):
    """
    ENHANCED: Get patient with security verification
    """
    # Verify security flag from decorator
    if not getattr(request, 'patient_verified', False):
        logger.error("SECURITY: get_current_patient called without security verification")
        return None, None
    
    if not hasattr(request, 'patient'):
        logger.error("SECURITY: No patient attached to request")
        return None, None
    
    patient = request.patient
    
    # CRITICAL: Double-verify user ownership
    if patient.user.id != request.user.id:
        logger.error(f"SECURITY BREACH: Patient ownership verification failed in get_current_patient")
        return None, None
    
    # Create secure patient dict (with masked sensitive data)
    patient_dict = {
        'id': patient.id,
        'full_name': patient.full_name,
        'first_name': patient.user.first_name,
        'last_name': patient.user.last_name,
        'email_masked': mask_email(patient.user.email),
        'date_of_birth': patient.date_of_birth,
        'ohip_masked': mask_ohip(patient.ohip_number),
        'phone_masked': mask_phone(patient.primary_phone),
        'address_truncated': truncate_address(patient.address),
        # Emergency contact info should also be masked
        'emergency_contact_name': patient.emergency_contact_name,
        'emergency_contact_phone_masked': mask_phone(patient.emergency_contact_phone)
    }
    
    return patient, patient_dict

def mask_ohip(ohip_number):
    """Mask OHIP number for security"""
    if not ohip_number or len(ohip_number) < 4:
        return "****"
    return f"****-***-{ohip_number[-3:]}"

def mask_phone(phone_number):
    """Mask phone number for security"""
    if not phone_number:
        return "***-***-****"
    import re
    digits = re.sub(r'\D', '', phone_number)
    if len(digits) >= 4:
        return f"***-***-{digits[-4:]}"
    return "***-***-****"

def mask_email(email):
    """Mask email for security"""
    if not email or '@' not in email:
        return "***@***.com"
    local, domain = email.split('@', 1)
    if local:
        return f"{local[0]}***@{domain}"
    return "***@***.com"

def truncate_address(address):
    """Truncate address for security"""
    if not address:
        return "Address on file"
    lines = address.split('\n')
    return f"{lines[0]}..." if lines else "Address on file"
